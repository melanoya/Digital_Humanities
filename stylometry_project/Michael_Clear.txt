Multi-Identity and Multi-Key Leveled FHE from Learning with
Errors
Michael Clear? and Ciarán McGoldrick
School of Computer Science and Statistics,
Trinity College Dublin
{clearm, Ciaran.McGoldrick}@scss.tcd.ie

Abstract. Gentry, Sahai and Waters recently presented the first (leveled) identity-based fully homomorphic (IBFHE) encryption scheme (CRYPTO 2013). Their scheme however only works in the singleidentity setting; that is, homomorphic evaluation can only be performed on ciphertexts created with the
same identity. In this work, we extend their results to the multi-identity setting and obtain a multi-identity
IBFHE scheme that is selectively secure in the random oracle model under the hardness of Learning with
Errors (LWE). We also obtain a multi-key fully-homomorphic encryption (FHE) scheme that is secure
under LWE in the standard model. This is the first multi-key FHE based on a well-established assumption such as standard LWE. The multi-key FHE of López-Alt, Tromer and Vaikuntanathan (STOC 2012)
relied on a non-standard assumption, referred to as the Decisional Small Polynomial Ratio assumption.

1

Introduction

Fully homomorphic encryption (FHE) is a cryptographic primitive that facilitates arbitrary computation on
encrypted data. Since Gentry’s breakthrough realization of FHE in 2009 [1], many improved variants have
appeared in the literature [2–6].
A leveled FHE scheme allows an evaluator to evaluate a circuit of limited depth L. The parameter L must
be specified in advance when generating the public parameters of the scheme, whose size may depend on L.
Furthermore, a leveled homomorphic scheme allows L to be polynomial in the security parameter. A “pure”
fully homomorphic encryption scheme allows circuits of unlimited depth to be evaluated. However, for many
applications in practice, a leveled scheme is adequate.
Identity-Based Encryption (IBE) is centered around the notion that a user’s public key can be efficiently
derived from an identity string and system-wide public parameters / master public key. The public parameters
are chosen by a trusted authority (TA) along with a secret trapdoor (master secret key), which is used to
extract secret keys for user identities. The first secure IBE schemes were presented in 2001 by Boneh and
Franklin [7] (based on bilinear pairings), and Cocks [8] (based on the quadratic residuosity problem).
At Crypto 2013, Gentry, Sahai and Waters presented the first (leveled) identity-based fully homomorphic
encryption (IBFHE) scheme [6]. Their scheme is secure under the hardness of the Learning with Errors (LWE)
problem, a problem introduced by Regev [9] that has received considerable attention in cryptography due to
a known worst-case reduction to a hard lattice problem.
Gentry, Sahai and Waters described a compiler [6], which we call the GSW compiler, to transform an
LWE-based IBE satisfying certain properties into a leveled IBFHE. They showed that all known LWE-based
IBE schemes are compatible with their compiler. However, the GSW compiler only works in the singleidentity setting. In other words, the resulting IBFHE can only evaluate on ciphertexts created with the
same identity. Recently, a multi-identity IBFHE was described in [10], but that construction relies heavily
on indistinguishability obfuscation [11], and is therefore highly inefficient at the present time. Furthermore,
security cannot be based on a well-established computational problem. Our construction does not require
indistinguishability obfuscation and is the first multi-identity IBFHE, to the best of our knowledge, whose
security can be based on well-established problem.
Remark 1. Like [6], we omit the qualifier “leveled” for the rest of this paper since we focus only on leveled
(IB)FHE in this work.
Note that our multi-identity and multi-key leveled IBFHE are 1-hop homomorphic insofar as after evaluation
is complete, no further homomorphic evaluation can be carried out.
?

The author’s work is funded by the Irish Research Council EMBARK Initiative.

1.1

Multi-Identity Setting

Consider the following simplified scenario. Alice and Bob work in an organization C that avails of a semitrusted cloud server E. Let a and b denote the identity strings of Alice and Bob respectively. Their organization
C serves as a trusted authority and issues them secret keys for their respective identity strings. Public users
can send confidential data to Alice and Bob by encrypting it with their identity string and the master public
key (public parameters) published by C. Suppose this encrypted data is sent by external users to the cloud
server E. Furthermore, suppose some entity would like to perform some computation on E using encrypted
data intended for Alice and encrypted data intended for Bob. The result should only be decryptable (assuming
C is honest) by a collaborative effort made by Alice and Bob; they can run a multi-party computation protocol
to collaboratively decrypt the result without leaking their secret keys to each other.
Let ca and cb be ciphertexts created with identities a and b respectively. The goal is to allow computation
on ca and cb together. Assuming this could be achieved, let c0 denote the ciphertext that encrypts the result
of the computation. Intuitively, we expect the size of c0 to depend on the number of distinct identities (2 in
our example above i.e. a and b) because information about each identity must be “encoded” in c0 . But like
the single-identity setting, the size of c0 should be independent of the size of the circuit evaluated. Of course
we can naturally extend this notion to ciphertexts created under k distinct identities.
In the syntax of multi-identity IBFHE, a parameter D representing the number of distinct identities
tolerated in an evaluation is specified in advance of generating the public parameters. Like the parameter L
(the circuit depth supported), the size of the public parameters may depend on D.

Disjunctive Policies There is another way of viewing multi-identity IBFHE, which might be more useful in
some settings. It was mentioned in [12]? that access policies consisting of disjunctions can be achieved with
IBE. In this case, to issue a secret key for a policy fˆ(X) , X = ”MATH” OR X = ”CS”, the TA issues a
secret key for identity string “MATH” and a secret key for identity string “CS”. In this case, we view the
“identities” as attributes.
Suppose the TA issues a secret key SKfˆ = {sk”MATH” , sk”CS” } for fˆ to a professor working in both the
Mathematics and Computer Science departments in a university; this secret key comprises an IBE secret key
for identity string “MATH” and an IBE secret key for identity string “CS”. The professor can decrypt the
result of computation performed on ciphertexts with both attributes. This matches our intuition because her
policy fˆ permits her access to both attributes.

1.2

Our Results

Multi-Identity IBFHE Our central result in this paper is informally summarized in the following theorem
statement. The theorem is formally stated and proven later in the paper.
Theorem 1 (Informal). There exists a multi-identity IBFHE scheme that is selectively secure under the
Learning With Errors problem in the random oracle model.

Multi-Key FHE Our compiler for multi-identity IBFHE also works in the public-key setting. As a result, we
can obtain a multi-key FHE [13] from LWE in the standard model. In fact, multi-identity IBFHE can be seen
as an identity-based analog to multi-key FHE. The syntax of multi-key FHE from [13] entails a parameter
M , which specifies the maximum number of independent keys tolerated in an evaluation. The size of the
parameters and ciphertexts are allowed to depend polynomially on M . Note that M is fixed and specified in
advance of generating the scheme’s parameters. To the best of our knowledge, our multi-key FHE scheme is
the first such scheme (for a non-constant number of keys) that is based on a well-established problem such as
LWE; the construction from [13] relies on a non-standard computational assumption referred to therein as the
Decisional Small Polynomial Ratio (DSPR) assumption. Our scheme positively answers the question raised
in [13] as to whether other multi-key FHE schemes exist supporting polynomially-sized M .
?

The paper [12] attributes this observation to Brent Waters.

1.3

Our Approach: Intuition

We now give an informal sketch of our approach to achieving multi-identity IBFHE. This section is intended
to provide an intuition and many of the details are deferred to later in the paper. We remind the reader that
a matrix M is denoted by an uppercase symbol written in boldface, and a vector v is denoted by a lowercase
symbol written in boldface. The i-th element of v is denoted by vi . The inner product of two vectors a, b ∈ Znq
for some dimension n is written as ha, bi.
GSW single-identity IBFHE We start by briefly discussing the homomorphic properties of the GSW
IBFHE schemes from [6]. This discussion applies to any IBFHE constructed with their compiler. A ciphertext
in their scheme is an N × N matrix C over Zq whose entries are “small” with respect to q. Note that N is
a parameter that will be discussed later. A secret key for an identity id is an N -dimensional vector vid ∈ ZN
q
with at least one “large” coefficient; let this coefficient (say the i-th one) be vid,i ∈ Zq . The scheme can encrypt
“small” messages µ; an example to keep in mind is a message in {0, 1} . We say the matrix C encrypts µ under
identity id if C · vid = µ · vid + e ∈ ZN
q where e is a “small” noise vector (i.e. roughly speaking, each of its
coefficients is much less than q). As such, vid is an approximate eigenvector for the matrix C with eigenvalue
µ.
Homomorphic Operations
Suppose C1 and C2 encrypt µ1 and µ2 respectively; that is, Cj · vid = µj · vid + ej for j ∈ {1, 2}. An additive
homomorphism is supported. Let C+ = C1 + C2 . Then we have C+ · vid = (µ1 + µ2 ) · vid + (e1 + e2 ). The error
only grows slightly here, and as long as it remains “small”, we can recover the sum (µ1 + µ2 ). A multiplicative
homomorphism is also supported. Let C× = C1 · C2 . Then we have
C× · vid

=

C1 · (µ2 · vid + e2 )

=

µ2 · (µ1 · vid + e1 ) + C1 · e2

=

µ1 · µ2 · vid + µ2 · e1 + C1 · e2

=

µ1 · µ2 · vid + “small”.

Different Identities Now we give a flavor of how our multi-identity scheme operates. Suppose C1 encrypts
µ1 under identity id1 and C2 encrypts µ2 under identity id2 . Let v1 and v2 be the secret key vectors for id1
and id2 respectively. It holds that C1 · v1 = µ1 · v1 + e1 and C2 · v2 = µ2 · v2 + e2 where e1 , e2 ∈ ZN
q are
short vectors.
We would like to be able to perform homomorphic computation on both C1 and C2 together; that is, use
them both as inputs to the same circuit. Here we denote the circuit by C ∈ C. Suppose we could produce a
×2N
that encrypts µ0 = C(µ1 , µ2 ). More precisely, suppose that
resulting 2N × 2N ciphertext matrix Ĉ0 ∈ Z2N
q
Ĉ0

 
 
v1
v
0
·
= µ · 1 + e0
v2
v2

where e0 is “short”. Note that the size of Ĉ0 just depends (polynomially) on the number of distinct identities
(2 in this example).
Let v ∈ Zq2N be the vertical concatenation of the two vectors v1 and v2 . We could exploit the homomorphic
properties described above to obtain Ĉ0 if we could somehow transform C1 and C2 into 2N × 2N matrices
Cˆ1 and Cˆ2 respectively such that Ĉj · v = µj · v + ”small” for j ∈ {1, 2}. Technically this transformation turns
out to be difficult; we show how to abstractly accomplish it in Section 3 and concretely in Section 4.

2
2.1

Preliminaries
Notation

A quantity is said to be negligible with respect to some parameter λ, written negl(λ), if it is asymptotically
bounded from above by the reciprocal of all polynomials in λ. We use the notation [k] for an integer k to
denote the set {1, . . . , k}.

$

Distributions For a probability distribution D, we denote by x ←
− D the fact that x is sampled according to
$
D. We overload the notation for a set S i.e. y ←
− S denotes that y is sampled uniformly from S. Let D0 and
D1 be distributions. We denote by D0 ≈ D1 and the D0 ≈ D1 the facts that D0 and D1 are computationally
C

S

indistinguishable and statistically indistinguishable respectively.
Definition 1 (B-bounded distributions (Definition 2 [6])). A distribution ensemble {Dn }n∈N , supported
over the integers, is called B-bounded if
Pr

$

e←
−Dn

[|e| > B] = negl(n).

Matrices and Vectors A matrix M is denoted by an uppercase symbol written in boldface, and a vector
v is denoted by a lowercase symbol written in boldface. The i-th element of v is denoted by vi . The inner
product of two vectors a, b ∈ Znq for some dimension n is written as ha, bi.
2.2

Multi-Identity IBFHE

Definition 2. A Multi-Identity (Leveled) IBFHE scheme is defined with respect to a message space M, an
identity space I, a class of circuits C ⊆ M∗ → M and ciphertext space C. A Multi-Identity IBHE scheme is
a tuple of PPT algorithms (Setup, KeyGen, Encrypt, Decrypt, Eval) defined as follows:
• Setup(1λ , L, D):
On input (in unary) a security parameter λ, a number of levels L (circuit depth to support) and the number
of distinct identities D that can be tolerated in an evaluation, generate public parameters PP and a master
secret key MSK. Output (PP, MSK).
• KeyGen(MSK, id):
On input master secret key MSK and an identity id: derive and output a secret key skid for identity id.
• Encrypt(PP, id, m):
On input public parameters PP, an identity id, and a message m ∈ M, output a ciphertext c ∈ C that
encrypts m under identity id.
• Decrypt(skid1 , . . . , skidd , c):
On input d ≤ D secret keys skid1 , . . . , skidd for (resp.) identities id1 , . . . , idd and a ciphertext c ∈ C, output
m0 ∈ M if c is a valid encryption under identities id1 , . . . , idd ; output a failure symbol ⊥ otherwise.
• Eval(PP, C, c1 , . . . , c` ): On input public parameters PP, a circuit C ∈ C and ciphertexts c1 , . . . , c` ∈ C,
output an evaluated ciphertext c0 ∈ C.
More precisely, the scheme is required to satisfy the following properties:
• Over all choices of (PP, MSK) ← Setup(1λ ), d ≤ D, id1 , . . . , idd ∈ I, C : M` → M ∈ {C ∈ C : depth(C) ≤
L}, j1 , . . . , j` ∈ [d ], µ1 , . . . , µ` ∈ M, ci ← Encrypt(PP, idji , µi ) for i ∈ [`], and c0 ← Eval(PP, C, c1 , . . . , c` ):
• Correctness
Decrypt(sk1 , . . . , skd , c0 ) = C(µ1 , . . . , µ` )
(2.1)
for any ski ← KeyGen(MSK, idi ) for i ∈ [k]
• Compactness
|c0 | ≤ poly(λ, L, d )

(2.2)

where d ≤ D is the number of distinct identities; that is, d = |{j1 , . . . , i` }|.
The size of evaluated ciphertexts in our construction grows with d ≤ D.
2.3

Learning with Errors

The Learning with Errors (LWE) problem was introduced by Regev [9]. The goal of the computational form
of the LWE problem is to determine an n-dimensional secret vector s ∈ Znq given a polynomial number of
samples (ai , bi ) ∈ Zn+1
where ai is uniform over Znq and bi ← hai , si + ei ∈ Zq is the inner product of ai and
q
si perturbed by a small error ei ∈ Z that is sampled from a distribution χ over Z. We call the distribution
χ an error distribution (or noise distribution). The decision variant of the problem is to distinguish such
samples (ai , bi ) ∈ Zn+1
from uniform vectors over Zn+1
. The decisional variant is more commonly used in
q
q
cryptography, and is most relevant to our own work. As a result, without further qualification, when we refer
to LWE throughout this thesis we are referring to the decisional variant.

Definition 3 ((Decisional) Learning with Errors (LWE) Problem [9]). Let λ be a security parameter.
For parameters n = n(λ), q = q(λ) ≥ 2, and a distribution χ = χ(λ) over Z, the LWEn,q,χ problem is to
distinguish the following distributions:
$

$

• Distribution 0: The i-th sample (ai , bi ) ∈ Zn+1
is computed by uniformly sampling ai ←
− Znq and bi ←
− Zq .
q
$

• Distribution 1: Generate uniform vector s ←
− Znq . The i-th sample (ai , bi ) ∈ Zn+1
is computed by
q
$

$

uniformly sampling ai ←
− Znq , sampling an error value ei ←
− χ and computing bi ← hai , si + ei .
Definition 4 (B-bounded distributions (Definition 2 [6])). A distribution ensemble {Dn }n∈N , supported
over the integers, is called B-bounded if
Pr

$

e←
−Dn

[|e| > B] = negl(n).

Definition 5 (GapSVPγ ). Let n be a lattice dimension, and let d be a real number. Then GapSVPγ is the
problem of deciding whether an n-dimensional lattice has a nonzero vector shorter than d (an algorithm should
accept in this case) or no nonzero vector shorter than γ(n) · d (an algorithm should reject in this case); an
algorithm is allowed to error otherwise.
Theorem 2 (Theorem 1 [6]). Let q√= q(n) ∈ N be either a prime power or a product of small (poly(n))
distinct primes, and let B ≥ ω(log n) · n. Then there exists an efficient sampleable B-bounded distribution χ
such that if there is an efficient algorithm that solves the average-case LWEn,q,χ problem, then:
• There is an efficient quantum algorithm that solves GapSVPÕ(nq/B) on any n-dimensional lattice.
• If q > Õ(2n/2 ), then there is an efficient classical algorithm for GapSVPÕ(nq/B) on any n-dimensional
lattice.
2.4

GSW Approximate Eigenvector Cryptosystem

Recall our brief overview of the GSW IBFHE construction earlier from Section 1.3. The following exposition
describes this construction in more detail. Note that the public-key GSW scheme is similar to the identitybased variant. As such, to simplify the notation, the following discussion deals with the public-key setting, but
the ideas apply to both.
Definition 6 (Section 1.3.2 from [6]). B-boundedness: Let B < q be an integer. Let C be a ciphertext
matrix that encrypts µ. Let v be a secret key vector such that C · v = µ · v + e. Then C is said to be B-bounded
(with respect to v) if the magnitude of µ is at most B, the magnitude of all the entries of C is at most B, and
k|ek|∞ ≤ B.
Let C1 and C2 be two B-bounded ciphertext matrices. Then C+ = C1 + C2 is 2B-bounded. Furthermore,
L
2
C× = C1 · C2 is (N + 1)B -bounded. As the authors of [6] point out, the error grows worse than B 2 , where
L is the multiplicative depth of a circuit being evaluated. The modulus q can be chosen to exceed this bound,
but we must be careful to ensure that the ratio q/B is at most subexponential in N to guarantee security
(see Theorem 2). Hence, only circuits of logarithmic multiplicative depth can be evaluated. This gives us a
somewhat-homomorphic scheme.
To evaluate deeper circuits, namely those with polynomial multiplicative depth, we must keep the entries
of the ciphertext matrices “small”. To achieve this, Gentry, Sahai and Waters propose a technique called
flattening. Consider the following definition.
Definition 7 (Section 1.3.3 from [6]). B-strong-boundedness: Let B < q be an integer. Let C be a
ciphertext matrix that encrypts µ. Let v be a secret key vector such that C · v = µ · v + e. Then C is said to
be B-strongly-bounded (with respect to v) if the magnitude of µ is at most 1, the magnitude of all the entries
of C is at most 1, and k|ek|∞ ≤ B.
An example of a B-strongly-bounded ciphertext is a matrix C with binary entries that encrypts a plaintext bit
µ ∈ {0, 1}, provided the coefficients of its corresponding e vector have magnitude at most B. Let C1 and C2

be ciphertext matrices that encrypt µ1 ∈ {0, 1} and µ2 ∈ {0, 1} respectively. A NAND gate can be evaluated
on two ciphertexts C1 and C2 as follows:
C3 = IN − C1 · C2 ,
where IN is the N × N identity matrix. The matrix C3 encrypts µ1 NAND µ2 ∈ {0, 1}. Now if C1 and C2 are
B-strongly-bounded, then the coefficients of C3 ’s error vector have magnitude at most (N + 1)B, which is in
contrast to (N +1)B 2 above where C1 and C2 were just B-bounded. Suppose there were some way to preserve
strong-boundedness in C3 (i.e. to ensure the magnitude of its entries remained at most 1). Then it would be
the case that C3 is (N + 1)B-strongly-bounded. As a result, the error level would grow to at most (N + 1)L B
when evaluating a circuit of NAND gates of depth L. Therefore it would be possible to evaluate circuits of
polynomial depth by letting q/B be subexponential. However, how can we preserve strong-boundedness? It
is necessary to introduce some basic operations to help describe how strong boundedness is preserved. These
operations serve as useful tools for our own constructions later.
0

0
0
Basic Operations Let `q = blg qc+1. Let v ∈ Zm
q be a vector of some dimension m over Zq . Let N = m ·`q .
0

• BitDecomp(v): We define an algorithm BitDecomp that takes as input a vector v ∈ Zm
and outputs
q
an N -dimensional vector (v1,0 , . . . , v1,`q −1 , . . . , vk,0 , . . . , vk,`q −1 ) where vi,j is the j-th bit in vi ’s binary
representation (ordered from least significant to most significant).
• BitDecomp−1 (v 0 ): We define an “inverse” algorithm BitDecomp−1 that takes an N -dimensional vector
P`q −1 j 0
P`q −1 j
0
0
0
0
v 0 = (v1,0
, . . . , v1,`
, . . . , vk,0
, . . . , vk,`
), and outputs a m0 -dimensional vector ( j=0
2 ·v1,j , . . . , j=0
2 ·
q −1
q −1
0
). Note that the input vector v 0 need not be binary, the algorithm is well-defined for any input vector
vk,j
in ZN
q .
• Flatten(v 0 ): The algorithm Flatten takes as input an N -dimensional vector v 0 ∈ ZN
q and outputs an
N -dimensional binary vector BitDecomp(BitDecomp−1 (v 0 ) ∈ {0, 1}N .
0
and outputs an N • Powersof2(v): The algorithm Powersof2 takes a m0 -dimensional vector v ∈ Zm
q
dimensional vector (v1 , 2v1 , . . . , 2`q −1 v1 , . . . , vk , 2vk , . . . , 2`q −1 vk ).
We also define BitDecomp, BitDecomp−1 and Flatten for matrix inputs; in this case, the respective algorithm
is applied to each row independently.
0
0
We restate the following straightforward facts from [6] (Section 1.3.3): Let a, b ∈ Zm
q be m -dimensional
0
N
vectors, and let a ∈ Zq be an N -dimensional vector:
• hBitDecomp(a), Powersof2(b)i = ha, bi.
• ha0 , Powersof2(b)i = hBitDecomp−1 (a0 ), bi = hFlatten(a0 ), Powersof2(b)i.
Flattening With the help of BitDecomp, BitDecomp−1 , Powersof2 and Flatten, we can tackle the problem of
preserving strong boundedness after a NAND operation. In order to make the coefficients of C3 above have
magnitude at most 1, Gentry, Sahai and Waters propose to apply Flatten to the matrix C3 . Thus, we compute
CNAND ← Flatten(C3 ) to produce the output ciphertext of the NAND gate. Now for this to work, the vector
v must have a special form. More precisely, v is computed as Powersof2(s) ∈ ZN
q for some secret key vector
m0
0
0
s ∈ Zq for some m . Furthermore, the parameter N is defined as N = m · `q , where `q = blg qc + 1. With
this form of secret key vector v, it holds that Flatten(C) · v = C · v for any N × N matrix C. So CNAND will
have entries in {0, 1} and thus be strongly-bounded.
2.5

GSW Compiler for IBE in the Single-Identity Setting

The Gentry, Sahai and Waters (GSW) compiler from Crypto 2013 [6] (Section 4) allows transformation of an
IBE scheme based on the Learning with Errors (LWE) problem into a related IBFHE scheme, provided the
IBE scheme satisfies the following properties:
1. Property 1 (Ciphertext and secret key vectors): The secret key for identity id and a ciphertext
0
0
created under id are vectors sid , cid ∈ Zm
q for some m . The first coefficient of sid is 1.

2. Property 2 (Small Dot Product): If cid encrypts 0, then hcid , sid i is “small”.
3. Property 3 (Security): Encryptions of 0 are indistinguishable from uniform vectors over Zq under the
hardness of LWE.
As noted in [6] all known LWE-based IBE schemes satisfy the above properties e.g: [14–17].
Let E be an IBE satisfying the Properties 1-3 above. Then E can be transformed into a single-identity
IBFHE scheme E 0 .
The public parameters PP generated by E.Setup includes a modulus q and an integer m0 representing the
length of both secret key and ciphertext vectors in E. Let `q = blg qc + 1 and N = m0 × `q .
To encrypt a message µ ∈ {0, 1} under identity id ∈ I, the encryptor generates N encryptions of 0 using
0
E. More precisely, she computes ei ← E.Encrypt(PP, id, 0) ∈ Zm
for every i ∈ [N ]. The set of N vectors
q
0
N ×m0
e1 , . . . , eN form the rows of an N × m matrix E ∈ Zq
. Finally the encryptor computes the N × N
ciphertext matrix C ∈ {0, 1}N ×N as follows
C ← Flatten(µ · IN + BitDecomp(E))
where IN denotes the N × N identity matrix.
A secret key in E 0 for identity id is an N -dimensional vector vid derived from a secret key sid for identity
id in E. This is computed as vid ← Powersof2(sid ). Decryption of a ciphertext C with vid is as follows. By
construction of vid , it has at least one “large” coefficient; denote this by vid,i , To perform decryption, we take
the i-th row ci of matrix C, compute the inner product x ← hci , vid i = µ · vid,i + ei and output the plaintext
µ ← bx/vid,i e. This is correct because
C · vid = µ · vid + E · sid = µ · vid + “small”
where E · sid is “small” as a consequence of Property 2. It is also easy to see that semantic security for E 0
follows immediately from the fact that E satisfies Property 3.

3

A Compiler for Multi-Identity Leveled IBFHE

In this section, we present a new compiler that can transform an LWE-based IBE into a multi-identity IBFHE.
As we will see, achieving multi-identity IBFHE is far more difficult than single-identity IBFHE.
3.1

Intuition

Suppose E is an LWE-based IBE that satisfies properties 1 - 3 above. We can apply the GSW compiler to
yield an IBFHE scheme E 0 in the single-identity setting. Our goal is to construct a compiler for the multiidentity setting. Consider two ciphertexts C1 and C2 that encrypt µ1 and µ2 under identities id1 and id2
respectively. Let s1 and s2 be secret keys in the scheme E for identities id1 and id2 respectively. Accordingly,
a decryptor can compute v1 ← Powersof2(s1 ) and v2 ← Powersof2(s2 ). It holds that C1 · v1 = µ1 · v1 + e1
and C2 · v2 = µ2 · v2 + e2 where e1 , e2 ∈ ZN
q are short vectors.
We would like to be able to perform homomorphic computation on both C1 and C2 together; that is,
use them both as inputs in the same circuit. Here we denote the circuit by C ∈ C. We expect the size of
the resulting ciphertext to grow if id1 6= id2 . This is intuitive because the resulting ciphertext must encode
information about both identities. Assume that id1 6= id2 . The compactness condition of multi-identity IBFHE
allows the size of the resulting ciphertext to depend polynomially on the number of distinct identities d (in
×2N
this case d = 2). Suppose we could produce a resulting 2N ×2N ciphertext matrix C0 ∈ Z2N
that encrypts
q
0
µ = C(µ1 , µ2 ). More precisely, suppose that
 
 
v
v
C0 · 1 = µ0 · 1 + e0
v2
v2
where e0 is “short”. The size of the ciphertext matrix is quadratic in the number of distinct identities, and
thus satisfies the compactness condition. How can such a matrix C0 be computed?
The main idea behind our approach is to transform each input ciphertext matrix (i.e. C1 and C2 in this
example) into a corresponding d N × d N “expanded matrix” where d is the number of distinct identities (i.e.
d = 2 in our example).

×N
Consider any input ciphertext matrix C ∈ ZN
that encrypts a plaintext µ under identity id1 . We denote
q
2N ×2N
by Ĉ ∈ Zq
its corresponding “expanded matrix”. We require this expanded matrix to satisfy

Ĉ ·

 
 
v1
v
= µ · 1 + “small”.
v2
v2

Now Ĉ can be viewed as consisting of 2 × 2 submatrices in ZqN ×N . We denote the submatrix on row i and
×N
column j as Ĉi,j ∈ ZN
. To satisfy the “top” part of the above equation, it is sufficient to set Ĉ1,1 ← C
q
and Ĉ1,2 ← 0. To satisfy the “bottom” part of the equation, we need to find matrices X, Y ∈ {0, 1}N ×N such
that
X · v1 + Y · v2 = µ · v2 + “small”.
We refer to a pair of solution matrices (X, Y) as a “mask” because of the fact that they hide the plaintext µ
from a party that does not have a secret key for the recipient identity. In this section, we will abstract over
the process of finding solution matrices X and Y with respect to arbitrary identities. Towards this goal, we
introduce an abstraction called a masking system. In short, a masking system allows an encryptor to produce
information U ∈ {0, 1}∗ that allows an evaluator to derive matrices X and Y that solve the above equation
with respect to any arbitrary identity. Informally, an adversary without a secret key for the recipient identity
(id1 in the above example) learns nothing about µ given U , but can still efficiently derive solution matrices
X and Y with respect to any chosen identity. This notion is formalized in the next section, where we present
our compiler. A concrete construction of a masking system is presented in Section 4.2.
3.2

Abstract Compiler

We start by describing an abstract framework for multi-identity IBFHE from Learning with Errors (LWE).
Our compiler uses the aforementioned abstraction which we call a masking system. An additional prerequisite
for an IBE scheme E (beyond Properties 1-3) to work with our compiler is that there exists a masking system
MSE for E. First we provide a formal definition of a masking system.
Definition 8. Let E be an IBE scheme satisfying Properties 1-3. A masking system for E is a pair of PPT
algorithms (GenUnivMask, DeriveMask) defined as follows:
• GenUnivMask(PP, id, µ) takes as input public parameters PP for E, an identity id ∈ I and a message
µ ∈ {0, 1}, and outputs U ∈ {0, 1}∗ (referred to as a universal mask).
• DeriveMask(PP, U, id0 ) takes as input public parameters PP for E, a universal mask U ∈ {0, 1}∗ and an
identity id0 ∈ I, and outputs a pair of matrices (X, Y) ∈ (ZqN ×N )2 .
A masking system (GenUnivMask, DeriveMask) must satisfy the following properties:
• Correctness: Let w(·) be a polynomial associated with the masking system. Let w = w(λ). We refer to w as
the error expansion factor. For correctness, it is required that for any (PP, MSK) ← E.Setup(1λ ), any identi0
ties id, id0 ∈ I, any secret keys vid ← Powersof2(E.KeyGen(MSK, id)) ∈ ZN
q and vid0 ← Powersof2(E.KeyGen(MSK, id )) ∈
ZN
q , and any µ ∈ {0, 1}, and over all
• U ← GenUnivMask(PP, id, µ),
• (X, Y) ← DeriveMask(PP, U, id0 )
it holds that
Xvid + Yvid0 = µ · vid0 + e
(3.1)
where k|ek|∞ ≤ w · B.
• Security: The masking system is said to be secure if all PPT adversaries have a negligible advantage in
the following modified IND-X-CPA game for E where X ∈ {sID, ID}. The only change in the security game
is that the adversary is given U ∗ ← GenUnivMask(PP, id∗ , µb ) in place of the challenge ciphertext in the
$

original game, where b ←
− {0, 1} is the challenger’s random bit, id∗ is the adversary’s target identity, and
µ0 and µ1 are the challenge messages chosen by the adversary.
Our compiler can compile an IBE scheme E into a IBFHE scheme E 0 if the following conditions are met (for
completeness, we restate Properties 1-3 above):

CP.1: (Ciphertext and secret key vectors): The secret key for identity id and a ciphertext created under
0
0
id are vectors sid , cid ∈ Zm
q for some m . The first coefficient of sid is 1.
CP.2: (Small Dot Product): . If cid encrypts 0 under identity id, then e = hcid , sid i is “small” where sid is
generated as in CP.1. Formally, e is B-bounded; that is, k|ek|∞ ≤ B.
CP.3: (Security): Encryptions of 0 are indistinguishable from uniform vectors over Zq under the hardness
of LWE.
CP.4: (Masking System): There exists a masking system (GenUnivMask, DeriveMask) for E meeting the
correctness and security conditions of Definition 8.
Let MSE = (MSE GenUnivMask, MSE DeriveMask) be a masking system for E that satisfies CP.4. A formal description is now given of a generic scheme, which we call mIBFHE, that uses E and MSE . We have
mIBFHE.Setup = E.Setup and mIBFHE.KeyGen = E.KeyGen. The remaining algorithms are described as follows.
Encryption To encrypt a message µ under identity id ∈ I, an encryptor performs the following steps. The
encryptor computes the universal mask
U ← MSE .GenUnivMask(PP, id, µ)
and outputs the ciphertext CT := (id, type := 0, enc := U ). Setting the type component of CT to 0 indicates a
“fresh” ciphertext.
Evaluation The evaluator is given as input a circuit C ∈ C and a collection of ` ciphertexts CT1 :=
(id1 , type := 0, enc := U1 ), . . . , CT` := (id` , type := 0, enc := U` ).
Consider the set of distinct identities I = {id1 , . . . , id` }. Suppose that |I| = d ≤ ` is the number of distinct
identities. If d > D (i.e. the maximum supported number of distinct identities is exceeded), the evaluator
aborts the evaluation. For simplicity we re-label the distinct identities as id1 , . . . , idd . Thus, each distinct
identity in the collection is associated with a unique index in [d ]. Before evaluation can be performed, each
ciphertext must be “transformed” into a d N × d N matrix, which we call an expanded matrix. This is achieved
as follows.
Let (idr , type := 0, enc := U ) be a ciphertext whose associated identity has been assigned the index r ∈ [d ].
A matrix Ĉ ∈ Zqd N ×d N is formed as follows. Start by setting Ĉ to the zero matrix. Now Ĉ can be viewed as
×N
×N
consisting of d × d submatrices in ZN
. We denote the submatrix on row i and column j as Ĉi,j ∈ ZN
.
q
q
For i ∈ [d ]:
1. Run (Xi , Yi ) ← MSE .DeriveMask(PP, U, idi ).
2. Set Ĉi,i ← Yi .
3. Set Ĉi,r ← Flatten(Ĉi,r + Xi ). (The reason for addition here is to handle the special case of i = r).
This completes the process for computing the expanded matrix Ĉ. Consider an example where r = 1 and
d > 2. The expanded matrix looks like the following:


(Flatten(X1 + Y1 )


X2
Y2


Ĉ = 

..
..


.
.
Xd
Yd
Perform the steps above to produce the expanded matrix Ĉ(i) for every input ciphertext CTi . Then the
circuit C ∈ C is evaluated gate-by-gate (NAND gates) on the expanded matrices to yield a d N × d N matrix
Ĉ0 . Suppose each Ĉ(i) encrypts µi ∈ {0, 1}. Then Ĉ0 encrypts C(µ1 , . . . , µ` ). Finally, the evaluation algorithm
outputs the tuple CT0 := (id1 , . . . , idd , type := 1, enc := Ĉ0 ). Setting the type component to 1 indicates an
evaluated ciphertext. Note that the scheme is 1-hop homomorphic.

Decryption On input a ciphertext CT := (id1 , . . . , idd , type, enc) and a sequence of secret keys vid1 , . . . , vidd ∈
ZN
q where vidi is a secret key for idi for i ∈ [d ], the decryptor performs the following steps. Form the column
vector v as the vertical concatenation of the column vectors vid1 , . . . , vidd . If type = 0, parse enc as the universal
mask U , compute (X, Y) ← MSE .DeriveMask(PP, U, id1 ) and set C ← X + Y. Else if type = 1, parse enc as Ĉ
and set C ← Ĉ.
Recall that the first `q components of v are 1, . . . , 2`q −1 . Let i be an index such that vi = 2i ∈ (q/4, q/2].
Compute di ← hci , vi where ci is the i-th row of C and output µ0 ← bdi /vi e ∈ {0, 1}. This works to recover
the message because as a result of Equation 3.1 (in Definition 8), we have
Cv = µ · v + e
with k|ek|∞ ≤ w · B, where w is the error expansion factor associated with the masking system MSE .
Lemma 1. Let B be a bound such that all freshly encrypted ciphertexts are B-strongly-bounded. Let D and
L be positive integers. If q > 8 · w · B(DN + 1)L?? , then the scheme mIBFHE is correct and can evaluate
NAND-based Boolean circuits of depth L with any number of distinct identities d ≤ D.
See Appendix A for the proof of Lemma 1.
Theorem 3. Let E be an IBE scheme satisfying CP.1 - CP.4. Then E can be transformed into a multi-identity
IBFHE scheme E 0 .
Proof. The proof of the theorem is constructive. By CP.4, there exists a masking system MSE for E. The
multi-identity IBFHE scheme E 0 that we obtain is mIBFHE instantiated with E and MSE . By Lemma 1, the
scheme is correct. CP.4 implies that E 0 is IND-X-CPA secure for some X ∈ {sID, ID}.

4

Concrete Construction of Multi-Identity Leveled IBFHE

To exploit our compiler from the last section to obtain a multi-identity IBFHE, we need to find an LWEbased IBE scheme E that satisfies CP.1 - CP.4. The major obstacle is finding a scheme for which a secure
masking system can be constructed. A natural starting point is the IBE of Cash, Hofheinz, Kiltz and Peikert
(CHKP) [17], which is IND-ID-CPA secure in the standard model. This IBE was adapted by Gentry, Sahai and
Waters ( [6] Appendix A.1) to work with their compiler. There are difficulties however in developing a secure
masking system for this IBE. Instead, we consider the IBE of Gentry, Peikert and Vaikuntanathan (GPV) [14].
Unfortunately this scheme is only secure under LWE in the random oracle model. On the plus side, we show
that it enjoys the distinction of admitting a secure masking system, and as a consequence of Theorem 3 can
be compiled into a multi-identity IBFHE scheme.
4.1

The Gentry, Peikert and Vaikuntanthan (GPV) IBE

In the GPV scheme, the TA needs to use a lookup table ? ? ? to store secret keys that are issued to users in
order to ensure that only a single unique secret key is ever issued for a given identity. This is required for the
security proof in the random oracle model.
A hash function H : {0, 1}∗ → Znq (modeled as a random oracle in the security proof) is used to map
an identity string id ∈ {0, 1}∗ to a vector zid ∈ Znq . A formal description of the GPV scheme is now given.
Note that this variant has been adapted in the same manner as CHKP in [6] for compatibility with the GSW
compiler.
Let A ∈ Zn×m
be a matrix. We define the lattice Λ⊥ (A) = {x ∈ Zm : A · x = 0 mod q} as the space of
q
vectors orthogonal to the rows of A modulo q. GPV depends on two efficient probabilistic algorithms, which
are informally presented as follows:
• TrapGen(n, m, q): [18, 19] Generate a statistically uniform matrix A ∈ Zn×m
together with a short basis
q
S ∈ Zm×m for Λ⊥ (A). Output (A, S).
??



Note that N (which depends on n) is itself dependent on lg q. For security, it is required that q/B = 2n for some
 ∈ (0, 1). A discussion on parameters is provided in Section C.
???
Alternatively with the additional assumption of a PRF, a lookup table could be avoided by deterministically
deriving secret keys (i.e. obtaining random coins from the PRF).

n
• SamplePre(S, A, u): [14] Generate a “short” solution x ∈ Zm
q to the equation A · x = u ∈ Zq .

See Appendix C.1 for more background on these algorithms. Furthermore, see Appendix C for a discussion on
suitable parameter settings.
GPV.Setup(1λ ): Choose parameters n = n(λ), m = m(λ), q = q(λ), a noise distribution χ : Z. Let m0 = m+1.
These parameters are implicit in the public parameters PP below. Generate statistically uniform A ∈ Zn×m
q
together with a short basis S ∈ Zm×m of Λ⊥ (A) by running (A, S) ← TrapGen(n, m, q). Choose a collisionresistant hash function H : {0, 1}t → Znq . Output PP := (A, H) and MSK := S.
GPV.KeyGen(MSK, id ∈ {0, 1}∗ ): If (id, sid ) ∈ store, output sid and abort.
m0
Compute zid ← H(id) ∈ Znq . Compute wid ← SamplePre(S, A, zid ) ∈ Zm
q . Set sid ← (1, −wid ) ∈ Zq . Add
(id, sid ) to store. Output sid .
0
0
n
Let A0id = zid k A ∈ Zm
q . Observe that Aid · sid = 0 ∈ Zq .
0

0

m
GPV.Encrypt(PP, id ∈ {0, 1}∗ , µ ∈ {0, 1}): Compute zid ← H(id) ∈ Znq . Let A0id = zid k A ∈ Zm
q . Let µ ∈ Zq
$

be the vector of 0’s except with µ · bq/2c in the first coefficient. Choose random r ←
− Znq and small error vector
$

0

0

e←
− χm . Output cid ← r · A0id + e + µ ∈ Zm
q .
GPV.Decrypt(sid , cid ): Set δ ← hcid , sid i ∈ Zq . If δ is small, output 0; if δ − q/2 mod q is small, output 1;
otherwise, output ⊥.
It is easy to see that GPV fulfills CP.1 and CP.2. Furthermore, GPV can be shown to be IND-sID-CPA
secure in the random oracle model [14] under LWE, and CP.3 follows from the security proof. It remains to
construct a masking system for GPV.
4.2

A masking system for GPV

Relaxation: support for a single identity As a warm up, we consider a relaxation of a masking system.
In this relaxation, it is sufficient to find X and Y for only one identity id0 , specified by the encryptor.
More precisely, let id be the recipient’s identity and let id0 6= id be another identity known to the encryptor.
Furthermore, let v be a secret key for id and let v 0 be a secret key for id0 . Then the goal is to allow the
evaluator to find matrices X and Y satisfying
X · v + Y · v 0 = µ · v 0 + “small”,
where µ is the plaintext.
A trivial way to do this is for the encryptor to send an encryption D of µ under identity id0 along with the
ciphertext. Hence, X = 0, Y = D serves as a solution to the above equation. However, it is easy to see that
such a trivial solution violates semantic security, since a decryptor with a secret key v 0 for id0 (and no secret
key for id) can still recover the plaintext µ.
One strategy for remedying the above approach is to “hide” elements of D in another matrix R that can
be recovered only with access to a secret key for identity id. Removing elements of D prevents a user from
recovering µ with a secret key for id0 .
0
The i-th row of a ciphertext matrix D, denoted by di , corresponds to an m0 -dimensional vector d0i ∈ Zm
q ;
that is, d0i ← BitDecomp−1 (di ). Basically d0i is an E-encryption of 0 under identity id0 whose bi/`q c-th coefficient
Pm0
0
is shifted by µ · 2i mod `q . Property 1 ensures that d0i,1 = − j=2 s0j · d0i,j for an E secret key vector s0 ∈ Zm
q
for identity id0 .
We compute the i-th row of R as follows. We generate an E-encryption of 0 under id (recall that id is
0
0
0
the recipient’s identity), and denote this by ri0 ∈ Zm
q . We add di,1 (i.e. the first coefficient of di ) to the first
0
0
coefficient of ri0 ; that is, ri,1
← ri,1
+d0i,1 and finally set the i-th row of R as ri ← BitDecomp(ri0 ). Furthermore,
we recompute the i-th row of the matrix D as di ← BitDecomp((0, d0i,2 , . . . , d0i,m0 )). It follows that
R · v + D · v 0 = µ · v 0 + “small”.
So effectively what we are doing is stripping the first `q columns of D and “blinding” them in R.

However there is still a major weakness in this approach. Suppose a decryptor has access to two decryption
0
vectors u0 , v 0 ∈ ZN
q that decrypt ciphertexts with identity id . For example, the TA might have generated
distinct secret key vectors when issuing keys to different parties, and the parties may have shared that information. It is easy to see that
D · u0 − D · v 0 = µ · (u0 − v 0 ) + “small”,
which allows the decryptor to easily determine µ ∈ {0, 1}. Hence a necessary condition for the approach to
work is that there be a unique secret key vector for every identity. In fact, this is the primary reason our
techniques do not work for ABE. Technically, this restriction means that the system can only support simple
classes of access policies, namely classes of predicates with disjoint support sets, which includes the special
case of IBE. Fortunately, in the GPV scheme, only a single secret key is ever issued for a given identity.
Consider the following algorithm that formally captures the above process of generating X and Y for a
specified identity id0 .
• Mask(PP, id, id0 , µ):
1. For i ∈ [N ]:
0
(a) c ← E.Encrypt(PP, id0 , 0) ∈ Zm
q .
(b) d ← Flatten(( |{z}
0 , µ, |{z}
0 ) + BitDecomp(c)) ∈ {0, 1}N .
1,...,i−1

i+1,...,N
0

(c) d0 ← BitDecomp−1 (d) ∈ Zm
q .
0

(d) x0i ← E.Encrypt(PP, id, 0) ∈ Zm
q .
(e) x0i,1 ← x0i,1 + d01 .
(f) xi ← BitDecomp(x0i ) ∈ {0, 1}N .
(g) yi ← BitDecomp((0, d02 , . . . , d0m0 )) ∈ {0, 1}N .
2. Let x1 , . . . , xN be the rows of a matrix X ∈ {0, 1}N ×N .
3. Let y1 , . . . , yN be the rows of a matrix Y ∈ {0, 1}N ×N .
4. Output (X, Y).
Support for all identities In essence the Mask algorithm creates an encryption (in the mIBFHE scheme)
of µ under id0 , and “blinds” some of its columns with fresh encryptions of 0 under the recipient identity id.
As such a secret key for id is needed to recover µ. So far so good, the algorithm Mask allows an encryptor
to create a secure “mask” for a specific identity that he knows. But how can we create a succinct “universal
mask” from which “masks” for arbitrary identities can be derived? To achieve this, we need to take a look at
the vector c that is generated in Step 1a of Mask. Assuming that E is GPV, then c is a GPV encryption of 0.
Such a ciphertext in GPV is of the form
c = (hzid0 , ri + e, A · r + f ) ∈ Zm
q
$

$

$

0

0

where e ←
− χ, f ←
− χm , r ←
− Znq and zid0 = H(id0 ) ∈ Znq . Let s ∈ Zm
be a secret key for id0 . Then CP.2
q
Pm0
ensures that hc, si is “small”. Since the first coefficient of s is 1, we have c1 ≈ − i=2 si · ci (the symbol ≈
denotes equality up to “small” differences). But c1 = hzid0 , ri + e. Therefore. since e is “small”, it holds that
Pm0
hzid0 , ri ≈ − i=2 si · ci . Roughly speaking, Mask “blinds” the value hzid0 , ri ∈ Zq with a GPV encryption of
0 under identity id (i.e. the recipient of the ciphertext). To support all identities, the challenge is to provide a
way to construct a vector that “blinds” the inner product hzid0 , ri for any identity id0 chosen by the evaluator,
not the single identity predetermined as above by the encryptor.
We can solve this problem as follows. Let’s say id0 ∈ I is an arbitrary identity chosen by the evaluator (and
not known in advance by the encryptor). Recall the following property of BitDecomp from Section 2.4:
hzid0 , ri = hBitDecomp(zid0 ), Powersof2(r)i.
Our approach is to blind each coefficient of Powersof2(r), whose length is `q · n, by adding each coefficient to an
independent GPV-encryption of 0. Since GPV is additively homomorphic, the evaluator can take a subset-sum
of the resulting vectors in accordance with the binary decomposition of zid0 to produce a vector that blinds
the desired inner product hzid0 , ri.

To simplify notation, we define η = `q · n. In the masking system we now describe, a universal mask U for
(η·N )×m0
recipient identity id ∈ I and plaintext µ ∈ {0, 1} consists of two matrices: a “blinding matrix” B ∈ Zq
0
and a “universal matrix” U ∈ ZqN ×m , the latter is referred to as such because it can be viewed as an
“encryption” of µ under all identities, albeit without some columns that are “blinded” by B. The matrix B
0
is split into N submatrices, Bi ∈ Zη×m
for i ∈ [N ]. Suppose we take the i-th submatrix. Each row of this
q
submatrix blinds a coefficient of Powersof2(ri ). So taking a subset-sum of the rows of the submatrix according
0
to the binary decomposition of zid0 yields a vector in Zm
q that blinds the inner product hzid0 , ri i.
In more detail, each row of U corresponds to η rows of B. Let ui be the i-th row of U. Then ui is associated
0
with a η × m0 submatrix B(i) ∈ Zqη×m of B. Momentarily we will assume that i > `q because the first `q rows
of U require special attention. We define the vector u0i as follows:
u0i = (0, A · ri + ei ) ∈ Zm
q
$

0

$

where ri ←
− Znq and ei ←
− χm . The row ui has the following form:
0

ui = u0i + µi ∈ Zm
q


0
0 , µ, |{z}
0 ) ∈ Zm
where µi ← BitDecomp−1 ( |{z}
q .
1,...,i−1

i+1,...,N

0

Let id0 ∈ I be an arbitrary identity. Our goal is to obtain a vector x0i ∈ Zm
q with the following form:
x0i = (hzid0 , ri i + hzid , si i + “small”, A · si + “small”)
where si ∈ Znq is uniformly random. The vector x0i is basically the inner product δ = hzid0 , ri i ∈ Zq added to
an encryption of 0 under identity id. For simplicity of description, we say that x0i blinds the element δ ∈ Zq .
Naturally we can blind any element of Zq in a similar fashion. Using a secret key for id, such a value can
be unblinded, but not recovered outright (in effect, we obtain the element plus some noise). The matrix B(i)
consists of η = n · `q rows. The j-th row of B(i) blinds the j-th coefficient of Powersof2(ri ) ∈ Zηq . By taking
the binary decomposition of zid0 (i.e. z2id0 ← BitDecomp(zid0 ) ∈ {0, 1}η ), we can compute a vector such as x0i
that blinds the inner product hzid0 , ri i. This can be easily expressed as z2id0 · B(i) .
The case of i ∈ [`q ] needs special consideration. The reason for this is that the first component of u0i is
0, and if µ is added as above, then it is effectively sent in the clear. It suffices here to produce a blinding of
0
µ · 2i−1 for i ∈ [`q ]. We can do this by setting ui to zero i.e. ui ← 0 ∈ Zm
q for i ∈ [`q ]. Furthermore, we set
B(i) to the zero matrix except for the last row, which is set to a vector that blinds µ · 2i−1 . The effect this
has is that when we compute z2id0 · B(i) , we get a vector that blinds µ · 2i−1 as required. An obvious space
optimization is to remove the zero vectors from both B and U, but for the sake of brevity, we do not do this
here.
We now formally present our masking system for GPV. (which we call MSGPV ).
MSGPV .GenUnivMask(PP, id, µ) :
1.
2.
3.
4.

Compute zid ← H(id).
0
Set A0 ← 0 k A> ∈ Zn×m
, where 0 ∈ Znq .
q
id
>
n×m0
Set A ← zid k A ∈ Zq
.
For i ∈ [N ]:
(a) If i ≤ `q :
$

$

0

$

0

i. Generate r ←
− Znq and sample a short error vector e ←
− χm .
0

ii. Set ui ← 0 ∈ Zm
q .
0

iii. Set bj ← 0 ∈ Zm
q for j ∈ [η − 1].
0

iv. Set bη ← Aid · r + e + (µ · 2i−1 , 0, . . . , 0) ∈ Zm
q .
(i)
v. Form matrix B from the rows b1 , . . . , bη .
(b) Else if i > `q :
$

i. Generate r ←
− Znq and sample a short error vector e ←
− χm .
0

ii. c ← A0 · r + e ∈ Zm
q .

iii. r2 ← Powersof2(r) ∈ Zη .
iv. For j ∈ [η]:
$

0

A. Generate s ←
− Znq and sample a short error vector f ∈ Zm .
0

B. Set wj ← (r2j , 0, . . . , 0) ∈ Zm
q .
0

C. bj ← Aid · s + f + wj ∈ Zm
q .
(i)
v. Let B be the matrix formed by the rows b1 , . . . , bη .
vi. Set d ← 0 ∈ {0, 1}N .
vii. Set di ← µ.
viii. ui ← BitDecomp−1 (d + BitDecomp(c)).
0
5. Let B ∈ ZqN η×m be the matrix formed by vertically concatenating the matrices B(1) . . . , B(N) .
0
×m
6. Let U ∈ ZN
be the matrix whose rows are formed by u1 , . . . , uN .
q
7. Output U := (B, U).

MSGPV .DeriveMask(PP, U, id0 ) :
1. Parse U as (B, U).
2. Compute zid0 ← H(id0 ).
3. Set 1 ← (0, . . . , 0, 1) ∈ Znq .

BitDecomp(1)

BitDecomp(zid0 )

4. Form a matrix Z as follows: Z = 
..

.
5.
6.
7.
8.




.

BitDecomp(zid0 )

0

×m
X0 ← Z · B ∈ ZN
.
q
X ← BitDecomp(X0 ) ∈ {0, 1}N ×N .
Y ← BitDecomp(U) ∈ {0, 1}N ×N .
Output (X, Y).

It is easy to see from the definition of MSGPV .DeriveMask that the error expansion factor is w = η + 1.
This is because each row in an expanded matrix is formed from a row of X and a row of Y. But the former
decomposes into a sum of η ciphertexts (and hence error terms).
Theorem 4. [Informal] The masking system MSGPV is selectively secure in the random oracle model (i.e.
MSGPV meets the security condition of Definition 8).
A formal statement of Theorem 4 along with the proof is given in Appendix E.
4.3

Applying the Compiler

It is now possible to put all the pieces together. In more detail, we can now apply our compiler to the IBE
scheme GPV with the masking system MSGPV to yield an IND-sID-CPA secure multi-identity IBFHE in the
random oracle model.
Theorem 1. There exists a multi-identity leveled IBFHE scheme that is IND-sID-CPA secure in the random
oracle model under the hardness of LWE.
Proof. Let D be a maximum degree of composition to support, and let L be a desired number of levels. Let λ
be the security parameter. We show there exists a leveled IBFHE scheme with maximum degree of composition
D, maximum circuit depth L and security parameter λ.
Choose dimension parameter n = n(λ, L) and bound B = B(n). Lemma 1 requires
q > 8 · w · B(DN + 1)L

(4.1)

to ensure correctness. Note that w is the expansion factor of the masking system. Now the error expansion
factor of MSGPV is w = η + 1. But this can be simplified to N † . Theorem 4 requires m ≥ 2n lg q, and we have
N = (m+1) lg q. We need to set q first before setting these parameters (m and N ) because of their dependence
on q. To do so, q must be expressed without dependence on N . It can be straightforwardly derived from the
inequality 4.1 that a suitable q is given by
q = B · 2O(L lg nD)
with additional care taken to ensure q/B is subexponential in n.
Our parameter settings ensure that the GPV scheme meets CP.1, CP.2 and CP.3, three of the prerequisites
for our compiler in Section 3. Furthermore, the masking system MSGPV is secure (via Theorem 4). As a result,
CP.4 is additionally satisfied. Therefore, Theorem 3 ensures there exists a secure leveled IBFHE scheme, which
by virtue of our parameter settings above (which meet Lemma 1), can correctly evaluate L-depth circuits over
ciphertexts with at most D distinct identities .

5

Multi-Key FHE

If we replace the GPV IBE with the Dual-Regev public-key encryption scheme from [14], then we can obtain
a multi-key FHE. The only change in the masking system is that identity vectors (i.e. zid = H(id) ∈ Znq ) are
replaced with public-key vectors in Znq . As a result, the random oracle H is no longer needed, and security holds
in the standard model. However the ciphertexts are prohibitively large; see Appendix C.5 for an illustration
of the extent of their impracticality. To reduce the ciphertext size, the scheme can be adapted to RLWE;
see Appendix B for more details. Our Multi-Key schemes are the first to the best of our knowledge that is
based on well-established problem such as LWE (resp. RLWE) in the standard model (recall that the scheme
from [13] requires the non-standard Decisional Small Polynomial Ratio (DSPR) problem).

Acknowledgments
The authors would like to thank Fuqun Wang for pointing out errors in an earlier version of this paper.

References
1. Gentry, C.: Fully homomorphic encryption using ideal lattices. Proceedings of the 41st annual ACM Symposium
on Theory of Computing STOC 09 (2009) 169
2. Smart, N., Vercauteren, F.: Fully homomorphic encryption with relatively small key and ciphertext sizes. In Nguyen,
P., Pointcheval, D., eds.: Public Key Cryptography – PKC 2010. Volume 6056 of Lecture Notes in Computer Science.
Springer Berlin / Heidelberg (2010) 420–443
3. van Dijk, M., Gentry, C., Halevi, S., Vaikuntanathan, V.: Fully homomorphic encryption over the integers. In
Gilbert, H., ed.: Advances in Cryptology – EUROCRYPT 2010. Volume 6110 of Lecture Notes in Computer Science.
Springer Berlin / Heidelberg (2010) 24–43
4. Brakerski, Z., Vaikuntanathan, V.: Fully Homomorphic Encryption from Ring-LWE and Security for Key Dependent Messages, Advances in Cryptology – CRYPTO 2011. Volume 6841 of Lecture Notes in Computer Science.
Springer Berlin / Heidelberg, Berlin, Heidelberg (2011) 505–524
5. Brakerski, Z., Vaikuntanathan, V.: Efficient fully homomorphic encryption from (standard) lwe. In Ostrovsky, R.,
ed.: FOCS, IEEE (2011) 97–106
6. Gentry, C., Sahai, A., Waters, B.: Homomorphic encryption from learning with errors: Conceptually-simpler,
asymptotically-faster, attribute-based. In Canetti, R., Garay, J.A., eds.: CRYPTO (2013). Volume 8042 of Lecture
Notes in Computer Science., Springer (2013) 75–92
7. Boneh, D., Franklin, M.K.: Identity-based encryption from the weil pairing. In: CRYPTO ’01: Proceedings of the
21st Annual International Cryptology Conference on Advances in Cryptology, London, UK, Springer-Verlag (2001)
213–229
8. Cocks, C.: An identity based encryption scheme based on quadratic residues. In: Proceedings of the 8th IMA
International Conference on Cryptography and Coding, London, UK, Springer-Verlag (2001) 360–363
†

w = η + 1 = `q · n + 1 ≤ `q · m < N .

9. Regev, O.: On lattices, learning with errors, random linear codes, and cryptography. In: STOC ’05: Proceedings
of the thirty-seventh annual ACM symposium on Theory of computing, New York, NY, USA, ACM (2005) 84–93
10. Clear, M., McGoldrick, C.: Bootstrappable identity-based fully homomorphic encryption. Cryptology ePrint
Archive, Report 2014/491 (2014) http://eprint.iacr.org/.
11. Garg, S., Gentry, C., Halevi, S., Raykova, M., Sahai, A., Waters, B.: Candidate indistinguishability obfuscation
and functional encryption for all circuits. In: FOCS, IEEE Computer Society (2013) 40–49
12. Agrawal, S., Freeman, D.M., Vaikuntanathan, V.: Functional encryption for inner product predicates from learning
with errors. In Lee, D.H., Wang, X., eds.: ASIACRYPT. Volume 7073 of Lecture Notes in Computer Science.,
Springer (2011) 21–40
13. López-Alt, A., Tromer, E., Vaikuntanathan, V.: On-the-fly multiparty computation on the cloud via multikey fully
homomorphic encryption. In: Proceedings of the 44th symposium on Theory of Computing. STOC ’12, New York,
NY, USA, ACM (2012) 1219–1234
14. Gentry, C., Peikert, C., Vaikuntanathan, V.: Trapdoors for hard lattices and new cryptographic constructions. In:
STOC ’08: Proceedings of the 40th annual ACM symposium on Theory of computing, New York, NY, USA, ACM
(2008) 197–206
15. Agrawal, S., Boneh, D., Boyen, X.: Efficient lattice (H)IBE in the standard model. In: Proc. of Eurocrypt’10.
Volume 6110 of LNCS. (2010) 553–572
16. Agrawal, S., Boneh, D., Boyen, X.: Lattice basis delegation in fixed dimension and shorter-ciphertext hierarchical
ibe. In: CRYPTO. (2010) 98–115
17. Cash, D., Hofheinz, D., Kiltz, E., Peikert, C.: Bonsai trees, or how to delegate a lattice basis. [20] 523–552
18. Ajtai, M.: Generating hard instances of the short basis problem. In: ICAL ’99: Proceedings of the 26th International
Colloquium on Automata, Languages and Programming, London, UK, Springer-Verlag (1999) 1–9
19. Alwen, J., Peikert, C.: Generating shorter bases for hard random lattices. Cryptology ePrint Archive, Report
2008/521 (2008)
20. Gilbert, H., ed.: Advances in Cryptology - EUROCRYPT 2010, 29th Annual International Conference on the
Theory and Applications of Cryptographic Techniques, French Riviera, May 30 - June 3, 2010. Proceedings. In
Gilbert, H., ed.: EUROCRYPT. Volume 6110 of Lecture Notes in Computer Science., Springer (2010)
21. Lyubashevsky, V., Peikert, C., Regev, O.: On ideal lattices and learning with errors over rings. [20] 1–23
22. Lepoint, T., Naehrig, M.: A comparison of the homomorphic encryption schemes FV and YASHE. In: Progress in
Cryptology - AFRICACRYPT 2014 - 7th International Conference on Cryptology in Africa, Marrakesh, Morocco,
May 28-30, 2014. Proceedings. (2014) 318–335
23. Micciancio, D., Peikert, C.: Trapdoors for lattices: Simpler, tighter, faster, smaller. In: EUROCRYPT. (2012)
700–718

A

Proof of Lemma 1

Lemma 1. Let B be a bound such that all freshly encrypted ciphertexts are B-strongly-bounded. Let D and L be positive
integers. If q > 8 · w · B(DN + 1)L‡ , then the scheme mIBFHE is correct and can evaluate NAND-based Boolean circuits
of depth L with any number of distinct identities d ≤ D.
Proof. Let the d ≤ D distinct identities involved in an evaluation be id1 , . . . , idd . Consider an expanded matrix derived
from a “fresh” ciphertext CT = (idi , type := 0, enc := U ) associated with identity idi for some i ∈ [d ]. Let v j be
a secret key that decrypts ciphertexts with identity idj for j ∈ [d ]. Let v̂ be the column vector consisting of the
concatenation of v 1 , . . . , v d . Let Ĉ be the expanded matrix for CT computed with respect to identities id1 , . . . , idd and
×N
(Xj , Yj ) ← MSE .DeriveMask(PP, U, idj ) for j ∈ [d ] . Now by construction, Ĉ consists of d × d submatrices in ZN
.
q
N ×N
There are 2 non-zero submatrices on N − 1 rows when Ĉ is viewed as d × d matrix over Zq
, and one non-zero
submatrix on the i-th row. The correctness condition for the masking system MSE gives us

   

 
Y1
X1
v1
X1 v1 + Y1 v1
v1
..
..

  ..  

 .. 
..

  .  

 . 
.
.
.

   

 

 vi  + ’small’ .





Flatten(X
+
Y
)
v
X
v
+
Y
v
·
=
=
µ
·
i
i
i i 
  i  i i
 


  .  

 . 
.
.
.
..
..
..

  ..  

 .. 
Xd
Yd
vd
Xd vd + Yd vd
vd
Since each of these submatrices is B-strongly-bounded, it follows that Ĉ · v̂ = µ · v̂ + ê where the coefficients of the error
vector ê are bounded by w · B.Therefore, Ĉ is w · B-strongly-bounded. Multiplying two d N × d N expanded matrices
‡



Note that N (which depends on n) is itself dependent on lg q. For security, it is required that q/B = 2n for some
 ∈ (0, 1). A discussion on parameters is provided in Section C.

in a NAND operation produces a matrix that is w · B(d N + 1)-strongly-bounded. After L successive levels, the bound
on the error is w · B(d N + 1)L . For correctness of decryption we need w · B(d N + 1)L < q/8. Since we have d ≤ D, it
follows that
8 · w · B(DN + 1)L
q
w · B(d N + 1)L ≤ w · B(DN + 1)L ≤
< .
8
8
u
t

B

Multi-Key FHE Based on RLWE

The Ring Learning with Errors (RLWE) assumption was introduced by Lyubashevsky, Peikert and Regev [21]. It is an
algebraic variant of LWE and it can be reduced to worst-case problems on ideal lattices. Despite the special structure of
ideal lattices, no algorithm has been found for SVP or another well-known lattice problem that performs better on ideal
lattices than on general lattices [21]. Where LWE is defined on vectors over Zq , RLWE is defined over a polynomial
ring Zq [x]/f (x).
Our compiler is compatible with several public-key RLWE schemes including the scheme of Lyubashevsky, Peikert
and Regev (LPR) [21], which Gentry, Sahai and Waters adapt to the approximate eigenvector framework in [6]. The only
issue we need focus on here that is not discussed in [6] is our masking system. Fortunately the approach underlying
our masking system for GPV is directly applicable to LPR. Instead of blinding inner products over Zq , one blinds
products in the ring Rq = Zq [x]/f (x). In LPR, the modulus polynomial is f (x) = xd + 1 for some d = d(λ). The public
parameters include a uniformly random element a(x) ∈ Rq . The public key of a user is an element b(x) ∈ Rq of the
form b(x) = a(x)s(x) + e(x), where the secret key s(x) is a uniformly random polynomial in Rq and e(x) is an error
polynomial drawn from an error distribution χR (analogous to χ but defined over R = Z[x]/f (x)). A ciphertext c in
LPR that encrypts zero under the public key b(x) is a pair of elements (c1 (x), c2 (x)) ∈ Rq where c1 (x) = b(x)r(x)+e1 (x)
and c2 (x) = a(x)r(x) + e2 (x) with r(x), e1 (x), e2 (x) independently sampled from χR . This scheme can be compiled
via the GSW compiler to yield a fully-homomorphic system whose ciphertexts are 2`q × 2`q matrices over Rq , where
`q = blg qc + 1.
Let pk = b(x) ∈ Rq be the public key of the recipient in the following discussion. Recall the masking system from
2` ×2
(η·2` )×2
Section 4.2. Adapting it to the scheme above, a universal mask consists of two matrices U ∈ Rq q and B ∈ Rq q
2
with η = `q . Consider the i-th row ui ∈ Rq of U for i > `q . The second column of ui is of the form a(x)r(x) + e(x) + µ0
$

− χR where µ0 = µ · 2i mod `q is a shifted version of the message µ ∈ {0, 1}. Let pk0 = b0 (x) ∈ Rq be
for some r(x), e(x) ←
an arbitrary public key. Our goal is to produce an LPR ciphertext that blinds the product b0 (x)r(x) ∈ Rq . This can be
(j)
(j)
(j)
(j)
obtained from a set of `q ciphertexts {(e1 (x), e2 (x))}0≤j<`q in which (e1 (x), e2 (x)) blinds the element 2j r(x) ∈ Rq
for 0 ≤ j < `q More precisely to compute a ciphertext (t1 (x), t2 (x)) that blinds the product b0 (x)r(x), one computes
P
Pd−1 P`q −1 0 (j)
P`q −1 0 (j)
0
k
k
0
t1 (x) ← d−1
j=0 bk,j e1 (x)x and t2 (x) ←
j=0 bk,j e2 (x)x where b(k,j) ∈ {0, 1} is the j-th bit of bk for
k=0
k=0
(j)

(j)

0 ≤ k < d and 0 ≤ j < `q . The elements {(e1 (x), e2 (x))}0≤j<`q form the rows of a `q × 2 submatrix of the blinding
matrix B; this submatrix corresponds to the i-th row. However, since there are 2`q rows in U, this means that B is a
(2`q · `q ) × 2 matrix over Rq . Furthermore, U is a 2`q × 2 matrix over Rq . Since a fresh ciphertext in our scheme consists
of the pair (B, U), we have that it consists of ((2`q · `q ) · 2) + 4`q = 4`q (1 + `q ) elements of Rq . Choosing n = 16384
and `q = 462 (this 33% smaller than the value that satisfies our correctness bound due to experimental results that
suggests the noise grows slower than expected [22]) for 80 bits of security [22] and to allow evaluation of L = 40 levels
with N = 100 distinct keys yields a ciphertext size of approximately 754 GB per bit of plaintext. Suppose one were to
use the scheme to encrypt an 80-bit symmetric key, we would obtain a 59 TB ciphertext, which is severely impractical.
In the next section, parameters are discussed for our multi-identity scheme based on standard LWE.

C

Parameters for our Scheme

Before discussing how parameters are chosen for our scheme, more background is needed on preimage sampling.

C.1

Background on Preimage Sampling

Let A ∈ Zn×m
be a matrix. We define the lattice Λ⊥ (A) = {x ∈ Zm : A · x = 0 mod q} as the space of vectors
q
orthogonal to the rows of A modulo q. There exist efficient algorithms to generate a statistically uniform matrix
A ∈ Zn×m
together with a short basis S ∈ Zm×m for Λ⊥ (A) [18, 19]. Such an algorithm will be simply called TrapGen
q
here; that is, we will write (A, S) ← TrapGen(n, m, q). We denote by S̃ the Gram-Schmidt orthonormalization of a basis
S. Let L = kS̃k be the norm of S. There are instances of TrapGen that achieve L = m1+ for any  > 0 [14], although
this has been improved upon in other works [23]. Hence, our setting of L later will be a conservative choice.

Let d and t be positive integers with d ≤ t. Let B ∈ Rd×t be a basis for a d-dimensional lattice Λ(B) ⊂ Rt . Then
the discrete Gaussian distribution on Λ(B) with center c ∈ Rt and standard deviation σ ∈ R is denoted by DΛ(B),s,c .
When c is understood to be zero, the center parameter is omitted.
Gentry, Peikert and Vaikuntanthan [14] describe an algorithm to sample from a discrete Gaussian distribution on an
arbitrary lattice. They describe an efficient probabilistic algorithm
SampleD(B, σ, c) that samples from a distribution
√
that is statistically close to DΛ(B),σ,c , provided σ ≥ kB̃k · ω( log d).
n
n
n
Consider the function fA : Zm
q → Zq defined by f (x) = A · x ∈ Zq . Given any vector u ∈ Zq , a preimage of u
m
under fA is any x ∈ Zq with fA (x) = u.
n
It turns out SampleD can be used to efficiently to find short preimages x ∈ Zm
q such that A · x = u ∈ Zq for an
arbitrary vector u ∈ Zn
.
Consider
the
following
algorithm
SamplePre
from
[14].
Note
that
s
is
a
parameter
for
which
q
possible settings are given in the next section.
• SamplePre(S, A, u): Find an arbitrary solution t ∈ Zm
q (via linear algebra) such that A · t = u mod q. Sample a
$

vector e ←
− DΛ⊥ (A),s,−t by running e ← SampleD(S, s, −t), and output the vector x ← e + t.
We remind the reader that there are improved variants of SamplePre in the literature [23].

C.2

Preimage Distribution

√
√
We need s ≥ L · ω( log m) to satisfy Theorem 5.9 of [14]. Let Bpreimage ≥ n · s. Then the probability of the magnitude
of any coefficient of a preimage vector exceeding Bpreimage is exponentially small in n via a standard tail inequality for
√
a normal distribution § . One possible setting is s = L · log m, and Bpreimage = n · s.

C.3

Noise Distribution

To satisfy Theorem 2, we need the noise distribution χ to be Bχ -bounded for some Bχ (to satisfy Theorem 2, we require
√
q/Bχ to be at most subexponential). Setting χ ← DZ,r with r = log m and Bχ ≥ n · r ensures that χ is Bχ -bounded,
$

since by the aforementioned tail inequality, we have that Pr[x ←
− DZ,r , |x| > Bχ ] is exponential in n.

C.4

Parameter B (B-strong-boundedness)

“Fresh” ciphertexts in our scheme are B-strongly-bounded. The parameter B is derived from the product of Bpreimage
and Bχ , since when the ciphertext matrix is multiplied by a secret key vector, the resulting error vector is formed
from the inner product of the noise vector in the ciphertext (drawn from χ) and the secret key (a sampled preimage).
Concretely, with the suggested parameter setting, we have B = L · n · log2 m. It is necessary that q/B1 is at most
subexponential in N . However, our analysis simplifies this by taking q/B to be subexponential; however, since Bpreimage
is polynomial in N , it also holds that q/Bχ is subexponential.

C.5

Sample Parameters and Ciphertext Size

Gentry, Sahai and Waters simplify their analysis by taking n to be a fixed parameter. This is a simplification because
q/B must be subexponential in n, and q depends on L; therefore in actuality n depends on L.
Let L be the desired number of levels and let D be the desired maximum number of distinct identities to support
in an evaluation. According to Lemma 1, correctness requires that
q > 8 · w · B(DN + 1)L .

(C.1)

In Section C.1, it was mentioned that L ≈ m. Putting this together with the derivation of B above in Section C.4
gives B = mn · log2 m, where m ≥ 2n lg q from Theorem 4. Choosing B in this way means that it is not too large and
allows us to derive lg q from the inequality C.1 above as follows: lg q = O(L(lg D + lg n)).
Consider the following concrete parameters. Suppose we require a circuit depth of L = 40 and a number of distinct
identities up to D = 100. We can satisfy the correctness constraint given by C.1 by setting lg q = dc · L(lg D + lg L) =
4 · 40(lg 100 + lg 40)e = 1915 (the constant c = 4 was chosen to meet the condition) and choosing the dimension to
be n = 2000. However the size of freshly encrypted ciphertexts in our leveled IBFHE scheme with these parameters is
greater than one exabyte (i.e. > 230 gigabytes) per bit of plaintext, which is extremely impractical. This illustrates the
impracticality of our scheme, but it also highlights the impracticality at the present time of the GSW leveled IBFHE
and ABFHE schemes.
§

A normal variable with standard deviation σ is within t · σ standard deviations of its mean, except with probability
at most 1t · t21/2 [14].
e

D

Size of Evaluated Ciphertexts

As mentioned in the previous section, n is not a fixed parameter that depends solely on the security level λ. Instead n
grows with both L and D because q/B must be subexponential in n to guarantee security. There is an optimization that
applies to both our construction and the GSW constructions in terms of the size of evaluated ciphertexts. Decryption
only requires a single row of a ciphertext matrix (see Section 3.2), so an evaluated ciphertext can have size d ·N where d
is the number of distinct identities in the evaluation. Let this vector be denoted by ĉ ∈ {0, 1}d ·N . Applying BitDecomp−1 ,
0
the vector c ← BitDecomp−1 (ĉ) ∈ Zm
is obtained. As explained in [6], if we include additional information in the
q
public parameters, the technique of modulus reduction [5] can be employed to each coefficient in c so that the size of
each coefficient can be made independent of D and L; their size must still depend on d to ensure correctness, but this
is allowed for by the compactness condition. However, while every coefficient can be reduced, the dimension cannot
be reduced. This is because the technique of dimension reduction [5] appears to be only compatible with the public
key setting since it relies on publishing encryptions of the secret key. We defer the details to [5]. So the length of
the ciphertext vector is the length of c, namely m0 , which in turn depends on both L and D. Therefore, technically
speaking, our multi-identity IBFHE in addition to both the IBFHE and ABFHE constructions of Gentry, Sahai and
Waters are not leveled in the strict sense of the size of an evaluated ciphertext being independent of L.

E

Proof of Theorem 4

Corollary 1 (Corollary 5.4 [14]). Let n be a positive√integer, and let q be a prime. Let m ≥ 2n lg q. Then for all
but a 2q −n fraction of all A ∈ Zn×m
and for any s ≥ ω( log m), the distribution of the syndrome u = Ae mod q is
q
statistically close to uniform over Zn
q , where e ∼ DZm ,s .
Theorem 4. Let n, m, q be chosen to meet Corollary 1. Let χ be a Bχ -bounded distribution where Bχ satisfies Theorem
2. Let TrapGen be an algorithm that generates a statistically uniform matrix A ∈ Zqn×m together with a basis S ∈ Zm×m
√
such that kS̃k ≤ L except with negligible probability. Let s ≥ L · ω( log m). Let the scheme GPV be instantiated with
TrapGen and the SamplePre algorithm (with parameter s) described in Section C.1.
Then the masking system MSGPV is selectively secure in the random oracle model (i.e. MSGPV meets the security
condition of Definition 8) under the hardness of LWEn,q,χ .
Proof. We prove the theorem by means of a hybrid argument.
Game 0: This is the standard selective security game described in Definition 8.
Game 1: The following changes are made in this game. Let id∗ ∈ I be the adversary’s target identity.
$

− Zn×m
is generated as uniformly random.
1. The matrix A ←
q
$

2. The vector zid∗ ←
− Zn
q is generated as uniformly random.
3. The random oracle H is simulated as follows: if the adversary A queries H on identity id ∈ I, run:
(a) If id = id∗ , then return zid∗ .
(b) Else if (id, sid , zid ) ∈ store, return zid .
0

$

(c) Else sample tid ←
− DZm0 −1 ,s , compute zid ← A · tid mod q, set sid ← (1, −tid ) ∈ Zm
q , add (id, sid , zid ) to store
and return zid .
(d) Secret key queries are answered as follows. Suppose A queries a secret key for identity id 6= id∗ . We assume
w.l.o.g. that A has first queried H on id. In response to the query, sid is returned where (id, sid , zid ) ∈ store.
We claim that A’s view in Game 0 is statistically close to A0 s view in Game 1. The first two changes above follow
immediately from the definition of GPV (in particular, the trapdoor basis generation algorithm employed guarantees
that a near uniform A can be generated). In regard to the simulation of H, Corollary 1 implies that the vector
H(id) when id 6= id∗ is statistically close to uniform. Finally, with regard to the distribution of secret keys, Lemma 5.2
from [14] states that a preimage tid sampled with SamplePre (with parameter s) in GPV.KeyGen is identically distributed
to tid ∼ DZm0 −1 ,s conditioned on Aid · tid = zid mod q. It follows that the secret keys sid in Game 1 have the same
distribution as Game 0.
For i ∈ [`q ]:
Game i + 1: This game is the same as the previous game except that Step 4(a)iv of MSGPV .GenUnivMask for iteration
i (only) is replaced with
$

0

bη ←
− Zm
q .
Suppose a distinguisher D has a non-negligible advantage distinguishing between Game i and Game i + 1. We can use
D to construct an algorithm B that can solve an LWE instance. Given an appropriate number of samples from either

$

$

$

− χ} : s ←
− Zn
− Zn
the distribution D0 := {{(uj , huj , si + ej ) : uj ←
q } or the distribution D1 := {{(uj , v j ) :
q , e)j ←
$

n×m
− Zn
and zid∗ ∈ Zn
uj , vj ←
q }}, the uj are used to construct A ∈ Zq
q . The algorithm B simulates the random oracle
H as explained above, and answers secret key queries in the manner described above. Note that the distribution of A
and zid∗ remain unchanged.
The algorithm B runs the same variant of MSGPV .GenUnivMask as the previous game. The only difference is that
on the i-th iteration, it replaces Step 4(a)iv with

bη ← x∗ + (µ · 2i , 0, . . . , 0) ∈ Zm
q
0

0

0

0

where x∗ ∈ Zm
is an LWE challenge vector that is either Aid · r + e ∈ Zm
or a uniformly random t∗ ∈ Zm
q
q
q . In the
former case, the view is statistically close to Game i whereas the view in the latter case is statistically close to Game
i + 1. It follows that B can output D’s guess to solve an LWE instance. The games are thus indistinguishable by the
hypothesized hardness of LWE.
As a shorthand for Game (`q + 1) + (i − `q − 1) · (η + 1) + j, we use the notation Game (i, j) for `q < i ≤ N and
j ∈ [η + 1].
For `q < i ≤ N :
For j ∈ [η]:
• Game (i, j): This game is the same as the previous game except that we change the way that the j-th row of B(i) is
generated in MSGPV .GenUnivMask. More precisely, Step 4(b)ivC of algorithm MSGPV .GenUnivMask is replaced with
$

bj ←
− Zm
q

0

for the specific case of the i-th iteration of the outer loop and the j-th iteration of the inner loop.
An analogous argument to the argument made above concerning the indistinguishability of Game i and i + 1 for
i ∈ [`q ] can be made here to show that a non-negligible advantage distinguishing between the games implies a
non-negligible advantage against LWE.
0

; in particular it does not rely
Remark 2. At this stage, note that B(i) from MSGPV .GenUnivMask is uniform over Zη×m
q
on r nor µ.
Game (i, η + 1): The modification in this game is as follows. Step 4(b)viii of MSGPV .GenUnivMask for the i-th iteration
is replaced with
0
$
− Zm
ui ←
q .
Once again an analogous LWE-based argument to that above shows that the vector c generated in Step 4(b)ii (for the
case of the i-th iteration) can be replaced with an LWE challenge, and indistinguishability between the games implies
a non-negligible advantage against LWE.
We conclude the proof by observing that in Game (N, η + 1), the plaintext bit µ has been eliminated entirely from
the generation of the universal mask U . It follows that an adversary has a zero advantage guessing the challenger’s bit
b, since no information about b is incorporated in the universal mask U given to the adversary.
u
t

